This is my attempt to do a little daily coding practice, finish a full Advent
of Code, learn Nim better, and stretch my literate programming efforts.

* Day 1: Chronal Calibration

  While I've never finished a full AoC I have done all of the Day 1 problems up
  to this point. They all seem relatively similar, having to do with
  counting. I imagine that's so that people can make sure their tools and
  project skeletons are properly set up before attempting the rest of the
  month. In any case, the problem itself is rather simple: Read a sign and
  number from each line, sum up said numbers, output the answer. I imagine the
  second star will be something like finding the max or min reached, when zero
  is crossed, etc. etc. For now no need to worry about that though.

  Some test data as given on the site:

  #+begin_src text :tangle data/test-1-0.txt
    +1
    -2
    +3
    +1
  #+end_src

  That should result in ~3~.

  #+begin_src text :tangle data/test-1-1.txt
    +1
    +1
    +1
  #+end_src

  That should result in ~3~.

  #+begin_src text :tangle data/test-1-2.txt
    +1
    +1
    -2
  #+end_src

  That should result in ~0~.

  #+begin_src text :tangle data/test-1-3.txt
    -1
    -2
    -3
  #+end_src

  That should result in ~-6~.

  My real data is in the same directory (=data/1.txt=).

  The file reading code is shamelessly stolen from [[http://howistart.org/posts/nim/1/index.html][the Nim How I Start]]. It
  reads in a file or stdin line by line, discards the last character (so we
  don't have to deal with the last newline creating an empty record), and opens
  a ~do~ block to map each line to an object. The ~ProblemLine~ type should be
  aliased in each day's solution to the proper type of each parsed line.

  #+name: read-problem-lines
  #+begin_src nim
    import os
    import sequtils
    import strutils

    let problem = (
      if paramCount() > 0: readFile paramStr 1 else: readAll stdin
    )[0..^2].splitLines.map do (line: string) -> ProblemLine:
  #+end_src

  Run like:

  #+begin_src sh
    nim c -r src/chronal_calibration data/1.txt
  #+end_src

  At this point Emacs stopped wanting to play nice with Nim (or vice versa). I
  hacked together the code in VSCode, came back and fixed Emacs, then dumped
  the code here. I rewrote the second bit to be functional, and it is very slow
  now.

  In this case each problem line is a tuple of ~char~ (~'+'~ or ~'-'~) and
  ~int~, the value to add or subtract. To parse this value, we can simply slice
  the line up and parse part of it using the standard lib.

  #+name: day-1-problem-line
  #+begin_src nim
    type ProblemLine = (char, int)
  #+end_src

  #+name: day-1-parse-line
  #+begin_src nim
    (line[0], parseInt line[1..^1])
  #+end_src

  The first half of the problem is extremely simple, a fold over each operation
  in the input. Since we parsed the problem input into a sequence of tuples
  there is a small helper function to dispatch addition or subtraction from a
  tuple and apply it to the input of each fold step. There may be a more
  elegant way to deal with the exceptional case, but it's basically unreachable
  code if we give the program good data.

  #+name: change-frequency
  #+begin_src nim
    func changeFrequency(start: int, change: (char, int)): int =
      case change[0]
      of '+':
        start + change[1]
      of '-':
        start - change[1]
      else:
        raise newException(AssertionError, "invalid leading character")
  #+end_src

  As said above, the fold itself is trivial. We output it right away as it's
  the answer.

  #+name: day-1-solution-1
  #+begin_src nim
    echo foldl(problem, changeFrequency(a, b), 0)
  #+end_src

  I hacked together a loop for the second problem, then came back and tried a
  recursive solution, blew the stack, then wrote a little trampoline to avoid
  blowing the stack. It was a fun exercise but the code is extremely
  slow. Dumping it all here to be fixed later; The goal is something both more
  functional and more Nim-my. I'll quite possibly have to write something
  similar to the existing code in ~sequtils~, but for infinite sequences a la
  Clojure.

  #+name: day-1-solution-2
  #+begin_src nim
    import sets

    func firstRevisited(
      changes: seq[(char, int)], changeIndex, frequency: int, visited: HashSet[int]
    ): (int, int, HashSet[int]) =
        let newChangeIndex = if changeIndex >= len(changes) - 1: 0
                             else: changeIndex + 1
        let newFrequency = changeFrequency(frequency, changes[changeIndex])
        var newVisited = initSet[int]()
        incl newVisited, frequency
        if contains(visited, newFrequency): (changeIndex, newFrequency, visited)
        else: (newChangeIndex, newFrequency, visited + newVisited)

    func firstRevisited(changes: seq[(char, int)]): int =
      var changeIndex = 0
      var frequency = 0
      var visited = initSet[int]()
      while true:
        let nextArgs = firstRevisited(changes, changeIndex, frequency, visited)
        if nextArgs[0] == changeIndex: return nextArgs[1]
        else:
          changeIndex = nextArgs[0]
          frequency = nextArgs[1]
          visited = nextArgs[2]

    echo firstRevisited(problem)
  #+end_src

  Finally, putting it all together.

  #+begin_src nim :comments noweb :noweb yes :tangle src/chronal_calibration.nim
    <<day-1-problem-line>>

    <<read-problem-lines>>
      <<day-1-parse-line>>

    <<change-frequency>>

    <<day-1-solution-1>>

    <<day-1-solution-2>>
  #+end_src

* Day 2: Inventory Management System

  Likewise, a dump. This has not been rewritten for either style or speed
  yet. It doesn't even fully solve the second problem: You have to read the
  results and figure out the letters yourself.

  #+begin_src nim :comments noweb :tangle src/inventory_management_system.nim
    import os
    import sequtils
    import strutils
    import tables

    let input = if paramCount() > 0: (readFile paramStr 1)[0..^2]
        else: readAll stdin

    let ids = splitLines input

    var withDoubles = 0
    var withTriples = 0
    for id in ids:
        var letters = initTable[char, int]()
        for letter in id:
            letters[letter] = if contains(letters, letter): letters[letter] + 1
                else: 1
        var doubles = false
        var triples = false
        for letter in keys letters:
            if letters[letter] == 2: doubles = true
            if letters[letter] == 3: triples = true
        withDoubles = if doubles: withDoubles + 1 else: withDoubles
        withTriples = if triples: withTriples + 1 else: withTriples
    echo withDoubles * withTriples

    func hamming(first, second: string): int =
        result = 0
        for i in countup(0, (len first) - 1):
            result = if first[i] == second[i]: result else: result + 1

    for i, firstId in pairs ids:
        for secondId in ids[i..^1]:
            if hamming(firstId, secondId) == 1:
                echo firstId
                echo secondId
  #+end_src

  Run it similarly.

  #+begin_src sh
    nim c -r src/inventory_management_system data/2.txt
  #+end_src

* Day 3: No Matter How You Slice It

  I imagine this will follow the same pattern...

  #+begin_src sh
    nim c -r src/no_matter_how_you_slice_it data/3.txt
  #+end_src

  It's an overlap problem. I feel like this is something easily solvable with
  math, but brute forcing at least the first part should work for now. First of
  all can pull in and modify the file reading code from the revised first
  day. This time with real types!

  First part is super messy and I'm not happy with the syntactic choices I
  made.

  Glad I decided to store claim info though. I've got a really nice data
  structure that I can just pull exactly what I need out of.

  #+begin_src nim :comments noweb :tangle src/no_matter_how_you_slice_it.nim
    import os
    import sequtils
    import sets
    import strutils
    import tables

    type Claim = tuple[id, x, y, width, height: int]

    let claims = map(splitLines(
      if paramCount() > 0: (readFile paramStr 1)
      else: readAll stdin
    )[0..^2]) do (line: string) -> Claim:
      let segments = splitWhitespace line
      result.id = parseInt segments[0][1..^1]
      let coords = split(segments[2], ",")
      result.x = parseInt coords[0]
      result.y = parseInt coords[1][0..^2]
      let dims = split(segments[3], "x")
      result.width = parseInt dims[0]
      result.height = parseInt dims[1]

    var fabric = initTable[(int, int), HashSet[int]]()

    iterator coordsFor(claim: Claim): (int, int) =
      for x in countup(claim.x, claim.x + claim.width - 1):
        for y in countup(claim.y, claim.y + claim.height - 1):
          yield (x, y)

    for claim in claims:
      for coord in coordsFor claim:
        let x = coord[0]
        let y = coord[1]
        if not hasKey(fabric, (x, y)): fabric[(x, y)] = toSet @[claim.id]
        else:
          incl fabric[(x, y)], claim.id

    let contestedClaims =
      filter(toSeq values fabric) do (cs: HashSet[int]) -> bool: len(cs) > 1

    echo len contestedClaims

    var goodClaims = toSet map(claims) do (c: Claim) -> int: c.id

    for contestedClaim in contestedClaims:
      excl goodClaims, contestedClaim

    echo goodClaims
  #+end_src

  #+begin_src text :tangle data/test-3-0.txt
    #1 @ 1,3: 4x4
    #2 @ 3,1: 4x4
    #3 @ 5,5: 2x2
  #+end_src

* Day 4: Repose Record

  #+begin_src sh
    nim c -r src/repose_record data/4.txt
  #+end_src

  #+begin_src nim :comments noweb :tangle src/repose_record.nim
    import algorithm
    import math
    import os
    import sequtils
    import strutils
    import tables

    type
      ReposeRecordKind = enum
        rrDuty
        rrWake
        rrSleep
      ReposeRecord = ref ReposeRecordObj
      ReposeRecordObj = object
        year: int
        month: int
        day: int
        hour: int
        minute: int
        case kind: ReposeRecordKind
        of rrDuty: id: int
        of rrWake, rrSleep: nil

    let unsortedRecords = (
      if paramCount() > 0: readFile paramStr 1 else: readAll stdin
    )[0..^2].splitLines.map do (line: string) -> ReposeRecord:
      result = ReposeRecordObj.new
      let dateSplit = line.split ']'
      let dateTimeSplit = dateSplit[0][1..^1].split ' '
      let dateParts = dateTimeSplit[0].split '-'
      result.year = parseInt dateParts[0]
      result.month = parseInt dateParts[1]
      result.day = parseInt dateParts[2]
      let timeParts = dateTimeSplit[1].split ':'
      result.hour = parseInt timeParts[0]
      result.minute = parseInt timeParts[1]
      let recordParts = dateSplit[1][1..^1].split ' '
      case recordParts[0][0]
      of 'G':
        result.kind = rrDuty
        result.id = parseInt recordParts[1][1..^1]
      of 'f':
        result.kind = rrSleep
      of 'w':
        result.kind = rrWake
      else:
        raise newException(AssertionError, "invalid leading character")

    let records = unsortedRecords.sorted do (x, y: ReposeRecord) -> int:
      result = x.year.cmp y.year
      if result == 0:
        result = x.month.cmp y.month
      if result == 0:
        result = x.day.cmp y.day
      if result == 0:
        result = x.hour.cmp y.hour
      if result == 0:
        result = x.minute.cmp y.minute

    var guards = initTable[int, CountTable[int]]()
    var currentGuard: int
    var lastAsleep: int

    for record in records:
      case record.kind
      of rrDuty:
        currentGuard = record.id
        if not guards.contains currentGuard:
          guards[currentGuard] = initCountTable[int]()
      of rrSleep:
        lastAsleep = record.minute
      of rrWake:
        for minute in lastAsleep.countup(record.minute - 1):
          if not guards[currentGuard].contains minute:
            guards[currentGuard][minute] = 1
          else:
            guards[currentGuard][minute].inc

    let sleepyGuards = toSeq(guards.pairs).sorted do (x, y: (int, CountTable[int])) -> int:
      toSeq(x[1].values).sum.cmp toSeq(y[1].values).sum

    let sleepiestGuard = sleepyGuards[^1]

    echo sleepiestGuard[0] * sleepiestGuard[1].largest[0]

    let consistentGuards = toSeq(guards.pairs).sorted do (x, y: (int, CountTable[int])) -> int:
      let xLargest = if x[1].len == 0: 0 else: x[1].largest[1]
      let yLargest = if y[1].len == 0: 0 else: y[1].largest[1]
      result = xLargest.cmp yLargest

    let mostConsistentGuard = consistentGuards[^1]

    echo mostConsistentGuard[0] * mostConsistentGuard[1].largest[0]
  #+end_src

  The test data from the problem page.

  #+begin_src text :tangle data/test-4-0.txt
    [1518-11-01 00:00] Guard #10 begins shift
    [1518-11-01 00:05] falls asleep
    [1518-11-01 00:25] wakes up
    [1518-11-01 00:30] falls asleep
    [1518-11-01 00:55] wakes up
    [1518-11-01 23:58] Guard #99 begins shift
    [1518-11-02 00:40] falls asleep
    [1518-11-02 00:50] wakes up
    [1518-11-03 00:05] Guard #10 begins shift
    [1518-11-03 00:24] falls asleep
    [1518-11-03 00:29] wakes up
    [1518-11-04 00:02] Guard #99 begins shift
    [1518-11-04 00:36] falls asleep
    [1518-11-04 00:46] wakes up
    [1518-11-05 00:03] Guard #99 begins shift
    [1518-11-05 00:45] falls asleep
    [1518-11-05 00:55] wakes up
  #+end_src

  Knock one record out of order to make sure the sorting implementation works.

  #+begin_src text :tangle data/test-4-1.txt
    [1518-11-05 00:55] wakes up
    [1518-11-01 00:00] Guard #10 begins shift
    [1518-11-01 00:05] falls asleep
    [1518-11-01 00:25] wakes up
    [1518-11-01 00:30] falls asleep
    [1518-11-01 00:55] wakes up
    [1518-11-01 23:58] Guard #99 begins shift
    [1518-11-02 00:40] falls asleep
    [1518-11-02 00:50] wakes up
    [1518-11-03 00:05] Guard #10 begins shift
    [1518-11-03 00:24] falls asleep
    [1518-11-03 00:29] wakes up
    [1518-11-04 00:02] Guard #99 begins shift
    [1518-11-04 00:36] falls asleep
    [1518-11-04 00:46] wakes up
    [1518-11-05 00:03] Guard #99 begins shift
    [1518-11-05 00:45] falls asleep
  #+end_src
